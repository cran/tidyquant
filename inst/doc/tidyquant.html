<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Matt Dancho" />


<title>Introduction to tidyquant</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Introduction to tidyquant</h1>
<h4 class="author"><em>Matt Dancho</em></h4>


<div id="TOC">
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#prerequisites">Prerequisites</a></li>
<li><a href="#benefits">Benefits</a><ul>
<li><a href="#a-few-core-functions-with-a-lot-of-power">A Few Core Functions with A Lot of Power</a></li>
<li><a href="#working-in-the-tidyverse">Working in the tidyverse</a></li>
<li><a href="#leverage-the-quantitative-power-of-xts-quantmod-and-ttr">Leverage the Quantitative Power of xts, quantmod and TTR</a></li>
<li><a href="#designed-to-be-used-and-scaled-with-the-tidyverse">Designed to be Used and Scaled with the tidyverse</a></li>
</ul></li>
<li><a href="#recap">Recap</a></li>
</ul>
</div>

<blockquote>
<p>Bringing quantitative financial analysis to the tidyverse</p>
</blockquote>
<div id="overview" class="section level1">
<h1>Overview</h1>
<p><code>tidyquant</code> integrates the best quantitative resources for collecting and analyzing quantitative data, <code>xts</code>, <code>quantmod</code> and <code>TTR</code>, with the tidy data infrastructure of the <code>tidyverse</code> allowing for seamless interaction between each and working within the <code>tidyverse</code>.</p>
<p>The three primary quantitative packages that are the backbone for quantitative financial analysis in <em>R programming</em> are:</p>
<ul>
<li><a href="https://CRAN.R-project.org/package=xts">xts</a>, or <a href="http://joshuaulrich.github.io/xts/index.html">eXtensible time series</a>: The data structure for handling time-series data.</li>
<li><a href="https://CRAN.R-project.org/package=quantmod">quantmod</a>, or <a href="http://www.quantmod.com/">Quantitative Financial Modelling &amp; Trading Framework for R</a>: A package designed for retrieving, manipulating, and modeling and quantitative data.</li>
<li><a href="https://CRAN.R-project.org/package=TTR">TTR</a>, or Technical Trading Rules: A package that includes various functions to compute technical trading equations for quantitative or trading data.</li>
</ul>
<p>The <a href="https://www.jstatsoft.org/article/view/v059i10">tidy data principles</a> are a cornerstone of data management and data modeling workflow. The foundation for tidy data management is the <code>tidyverse</code>, a collection of <em>R packages</em>: <code>ggplot2</code>, <code>dplyr</code>, <code>tidyr</code>, <code>purrr</code>, <code>readr</code>, <code>tibble</code>, that work in harmony, are built for scalability, and are well documented in <a href="http://r4ds.had.co.nz/">R for Data Science</a>. Using this infrastructure and the core tidy concepts, we can integrate the tidy data principles with the best quantitative financial analysis packages using the package, <code>tidyquant</code>.</p>
</div>
<div id="prerequisites" class="section level1">
<h1>Prerequisites</h1>
<p>Load the <code>tidyquant</code> package to get started.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Loads tidyquant, tidyverse, lubridate, xts, quantmod, TTR </span>
<span class="kw">library</span>(tidyquant)  </code></pre></div>
</div>
<div id="benefits" class="section level1">
<h1>Benefits</h1>
<p><strong>The <code>tidyquant</code> philosophy</strong>:</p>
<ul>
<li><strong>A few core functions with a lot of power, that</strong></li>
<li><strong>leverage the quantitative analysis power of <code>xts</code>, <code>quantmod</code> and <code>TTR</code>, and are</strong></li>
<li><strong>designed to be used and scaled with the <code>tidyverse</code>.</strong></li>
</ul>
<p><a class="anchor" id="core-functions"></a></p>
<div id="a-few-core-functions-with-a-lot-of-power" class="section level2">
<h2>A Few Core Functions with A Lot of Power</h2>
<p>Minimizing the number of functions reduces the learning curve. Functions are grouped into verbs for efficient collection and manipulation of quantitative data:</p>
<ul>
<li><p><strong>Get Quantitative Data, <code>tq_get()</code></strong>: A one-stop shop to get data from various web-sources.</p></li>
<li><p><strong>Transform, <code>tq_transform()</code>, and Mutate, <code>tq_mutate()</code>, Quantitative Data</strong>: These are the workhorse functions that wrap around the <code>xts</code>, <code>quantmod</code>, and <code>TTR</code> packages.</p></li>
<li><p><strong>Coerce Quantitative Data Between tibble and xts formats, <code>as_tibble()</code> and <code>as_xts()</code></strong>: Coercing <code>xts</code>, <code>zoo</code>, <code>timeSeries</code>, and the other various <em>R</em> time-based objects to and from <code>tibble</code> or <code>data.frame</code> objects was a pain due to the date/time being stored as row names in time-based objects. The tidyquant <code>as_tibble()</code> and <code>as_xts()</code> functions enable preservation of row names during coercion.</p></li>
</ul>
<p><a class="anchor" id="tq-get"></a></p>
<div id="get-quantitative-data" class="section level3">
<h3>Get Quantitative Data</h3>
<p>The <code>tq_get()</code> function is used to collect all data by changing the <code>get</code> argument. The options include stock lists for 18 stock indexes from marketvolume.com, stock prices, dividends and splits from Yahoo Finance, financial statements from Google Finance, metal prices and exchange rates from Oanda, and economic data from the FRED database. To see the full list, execute <code>tq_get_options()</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tq_get_options</span>()</code></pre></div>
<pre><code>## [1] &quot;stock.prices&quot;   &quot;stock.index&quot;    &quot;dividends&quot;      &quot;splits&quot;        
## [5] &quot;financials&quot;     &quot;economic.data&quot;  &quot;exchange.rates&quot; &quot;metal.prices&quot;</code></pre>
<p><strong>Stock Index</strong>:</p>
<p>A wide range of stock index / exchange lists can be retrieved using <code>get = &quot;stock.index&quot;</code>. To get a full list of the options, use <code>tq_get_stock_index_options()</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tq_get_stock_index_options</span>()</code></pre></div>
<pre><code>##  [1] &quot;DOWJONES&quot;    &quot;DJI&quot;         &quot;DJT&quot;         &quot;DJU&quot;         &quot;SP100&quot;      
##  [6] &quot;SP400&quot;       &quot;SP500&quot;       &quot;SP600&quot;       &quot;RUSSELL1000&quot; &quot;RUSSELL2000&quot;
## [11] &quot;RUSSELL3000&quot; &quot;AMEX&quot;        &quot;AMEXGOLD&quot;    &quot;AMEXOIL&quot;     &quot;NASDAQ&quot;     
## [16] &quot;NASDAQ100&quot;   &quot;NYSE&quot;        &quot;SOX&quot;</code></pre>
<p>Set <code>x</code> as one of the options in the list of options above, and <code>get = &quot;stock.index&quot;</code> to get the desired stock index / exchange.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tq_get</span>(<span class="st">&quot;sp500&quot;</span>, <span class="dt">get =</span> <span class="st">&quot;stock.index&quot;</span>)</code></pre></div>
<pre><code>## # A tibble: 501 × 2
##    symbol                   company
##     &lt;chr&gt;                     &lt;chr&gt;
## 1     MMM                        3M
## 2     ABT       ABBOTT LABORATORIES
## 3    ABBV                ABBVIE INC
## 4     ACN                 ACCENTURE
## 5    ATVI       ACTIVISION BLIZZARD
## 6     AYI             ACUITY BRANDS
## 7    ADBE             ADOBE SYSTEMS
## 8     AAP        ADVANCE AUTO PARTS
## 9     AET                     AETNA
## 10    AMG AFFILIATED MANAGERS GROUP
## # ... with 491 more rows</code></pre>
<p>The data source is <a href="http://www.marketvolume.com/indexes_exchanges/">www.marketvolume.com</a>.</p>
<p><strong>Stock Prices, Dividends and Splits</strong>:</p>
<p>The stock prices can be retrieved succinctly using <code>get = &quot;stock.prices&quot;</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">aapl_prices  &lt;-<span class="st"> </span><span class="kw">tq_get</span>(<span class="st">&quot;AAPL&quot;</span>, <span class="dt">get =</span> <span class="st">&quot;stock.prices&quot;</span>, <span class="dt">from =</span> <span class="st">&quot; 1990-01-01&quot;</span>)
aapl_prices </code></pre></div>
<pre><code>## # A tibble: 6,805 × 7
##          date   open   high   low  close   volume adjusted
##        &lt;date&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;
## 1  1990-01-02 35.250 37.500 35.00 37.250 45799600 1.132075
## 2  1990-01-03 38.000 38.000 37.50 37.500 51998800 1.139673
## 3  1990-01-04 38.250 38.750 37.25 37.625 55378400 1.143471
## 4  1990-01-05 37.750 38.250 37.00 37.750 30828000 1.147270
## 5  1990-01-08 37.500 38.000 37.00 38.000 25393200 1.154868
## 6  1990-01-09 38.000 38.000 37.00 37.625 21534800 1.143471
## 7  1990-01-10 37.625 37.625 35.75 36.000 49929600 1.094086
## 8  1990-01-11 36.250 36.250 34.50 34.500 52763200 1.048499
## 9  1990-01-12 34.250 34.750 33.75 34.500 42974400 1.048499
## 10 1990-01-15 34.500 35.750 34.25 34.250 40434800 1.040901
## # ... with 6,795 more rows</code></pre>
<p>Dividends are obtained using <code>get = &quot;dividends&quot;</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">aapl_divs &lt;-<span class="st"> </span><span class="kw">tq_get</span>(<span class="st">&quot;AAPL&quot;</span>, <span class="dt">get =</span> <span class="st">&quot;dividends&quot;</span>, <span class="dt">from =</span> <span class="st">&quot;1990-01-01&quot;</span>)
aapl_divs</code></pre></div>
<pre><code>## # A tibble: 42 × 2
##          date dividends
##        &lt;date&gt;     &lt;dbl&gt;
## 1  1990-02-16   0.00393
## 2  1990-05-21   0.00393
## 3  1990-08-20   0.00393
## 4  1990-11-16   0.00429
## 5  1991-02-15   0.00429
## 6  1991-05-20   0.00429
## 7  1991-08-19   0.00429
## 8  1991-11-18   0.00429
## 9  1992-02-14   0.00429
## 10 1992-06-01   0.00429
## # ... with 32 more rows</code></pre>
<p>Stock splits are obtained using <code>get = &quot;splits&quot;</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">aapl_splits &lt;-<span class="st"> </span><span class="kw">tq_get</span>(<span class="st">&quot;AAPL&quot;</span>, <span class="dt">get =</span> <span class="st">&quot;splits&quot;</span>, <span class="dt">from =</span> <span class="st">&quot;1990-01-01&quot;</span>)
aapl_splits</code></pre></div>
<pre><code>## # A tibble: 3 × 2
##         date    splits
##       &lt;date&gt;     &lt;dbl&gt;
## 1 2000-06-21 0.5000000
## 2 2005-02-28 0.5000000
## 3 2014-06-09 0.1428571</code></pre>
<p>The data source is <a href="https://finance.yahoo.com/">yahoo finance</a>.</p>
<p><strong>Financial Statements</strong>:</p>
<p>For any given stock, a total of six financials statements are retrieved as nested tibbles, one for each combination of statement type (Income Statement, Balance Sheet, and Cash Flow) and period (by annual and quarter).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fb_financials &lt;-<span class="st"> </span><span class="kw">tq_get</span>(<span class="st">&quot;FB&quot;</span>, <span class="dt">get =</span> <span class="st">&quot;financials&quot;</span>)
fb_financials</code></pre></div>
<pre><code>## # A tibble: 3 × 3
##    type             annual            quarter
## * &lt;chr&gt;             &lt;list&gt;             &lt;list&gt;
## 1    BS &lt;tibble [168 × 4]&gt; &lt;tibble [210 × 4]&gt;
## 2    CF  &lt;tibble [76 × 4]&gt;  &lt;tibble [76 × 4]&gt;
## 3    IS &lt;tibble [196 × 4]&gt; &lt;tibble [245 × 4]&gt;</code></pre>
<p>The statement information can be extracted by selecting (<code>dplyr::select()</code>) and filtering (<code>dplyr::filter()</code>) to the desired statement and unnesting (<code>tidyr::unnest()</code>) the results.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fb_financials %&gt;%
<span class="st">    </span><span class="kw">filter</span>(type ==<span class="st"> &quot;IS&quot;</span>) %&gt;%
<span class="st">    </span><span class="kw">select</span>(annual) %&gt;%
<span class="st">    </span><span class="kw">unnest</span>()</code></pre></div>
<pre><code>## # A tibble: 196 × 4
##    group             category       date value
##    &lt;int&gt;                &lt;chr&gt;     &lt;date&gt; &lt;dbl&gt;
## 1      1              Revenue 2015-12-31 17928
## 2      1              Revenue 2014-12-31 12466
## 3      1              Revenue 2013-12-31  7872
## 4      1              Revenue 2012-12-31  5089
## 5      2 Other Revenue, Total 2015-12-31    NA
## 6      2 Other Revenue, Total 2014-12-31    NA
## 7      2 Other Revenue, Total 2013-12-31    NA
## 8      2 Other Revenue, Total 2012-12-31    NA
## 9      3        Total Revenue 2015-12-31 17928
## 10     3        Total Revenue 2014-12-31 12466
## # ... with 186 more rows</code></pre>
<p>A slightly more powerful example is looking at all quarterly statements together. This is easy to do with <code>unnest</code> and <code>spread</code> from the <code>tidyr</code> package.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fb_financials %&gt;%
<span class="st">    </span><span class="kw">unnest</span>(quarter) %&gt;%<span class="st"> </span>
<span class="st">    </span><span class="kw">spread</span>(<span class="dt">key =</span> date, <span class="dt">value =</span> value)</code></pre></div>
<pre><code>## # A tibble: 110 × 8
##     type group                         category `2015-09-30` `2015-12-31`
## *  &lt;chr&gt; &lt;int&gt;                            &lt;chr&gt;        &lt;dbl&gt;        &lt;dbl&gt;
## 1     BS     1               Cash &amp; Equivalents         1621         2409
## 2     BS     2           Short Term Investments        11526        14322
## 3     BS     3  Cash and Short Term Investments        15834        18434
## 4     BS     4 Accounts Receivable - Trade, Net         2010         2559
## 5     BS     5              Receivables - Other           NA           NA
## 6     BS     6           Total Receivables, Net         2010         2559
## 7     BS     7                  Total Inventory           NA           NA
## 8     BS     8                 Prepaid Expenses         1295          659
## 9     BS     9      Other Current Assets, Total           NA           NA
## 10    BS    10             Total Current Assets        19139        21652
## # ... with 100 more rows, and 3 more variables: `2016-03-31` &lt;dbl&gt;,
## #   `2016-06-30` &lt;dbl&gt;, `2016-09-30` &lt;dbl&gt;</code></pre>
<p>The data source is <a href="https://www.google.com/finance">google finance</a>.</p>
<p><a class="anchor" id="economic-data"></a></p>
<p><strong>Economic Data</strong>:</p>
<p>A wealth of economic data can be extracted from the Federal Reserve Economic Data (FRED) database. The <a href="https://fred.stlouisfed.org/series/DCOILWTICO">WTI Crude Oil Prices</a> are shown below.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">wti_price_usd &lt;-<span class="st"> </span><span class="kw">tq_get</span>(<span class="st">&quot;DCOILWTICO&quot;</span>, <span class="dt">get =</span> <span class="st">&quot;economic.data&quot;</span>)
wti_price_usd </code></pre></div>
<pre><code>## # A tibble: 2,867 × 2
##          date price
##        &lt;date&gt; &lt;dbl&gt;
## 1  2006-01-02    NA
## 2  2006-01-03 63.11
## 3  2006-01-04 63.41
## 4  2006-01-05 62.81
## 5  2006-01-06 64.21
## 6  2006-01-09 63.56
## 7  2006-01-10 63.41
## 8  2006-01-11 63.91
## 9  2006-01-12 63.96
## 10 2006-01-13 63.86
## # ... with 2,857 more rows</code></pre>
<p>The FRED contains literally over 10K data sets that are free to use. See the <a href="https://fred.stlouisfed.org/categories">FRED categories</a> to narrow down the data base and to get data codes.</p>
<p><strong>Exchange Rates</strong>:</p>
<p>Exchange rates are entered as currency pairs using “/” notation (e.g <code>&quot;EUR/USD&quot;</code>), and by setting <code>get = &quot;exchange.rates&quot;</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">eur_usd &lt;-<span class="st"> </span><span class="kw">tq_get</span>(<span class="st">&quot;EUR/USD&quot;</span>, <span class="dt">get =</span> <span class="st">&quot;exchange.rates&quot;</span>, <span class="dt">from =</span> <span class="st">&quot;2000-01-01&quot;</span>)
eur_usd </code></pre></div>
<pre><code>## # A tibble: 1,827 × 2
##          date exchange.rate
##        &lt;date&gt;         &lt;dbl&gt;
## 1  2011-12-31       1.29618
## 2  2012-01-01       1.29590
## 3  2012-01-02       1.29375
## 4  2012-01-03       1.30038
## 5  2012-01-04       1.30036
## 6  2012-01-05       1.28717
## 7  2012-01-06       1.27698
## 8  2012-01-07       1.27195
## 9  2012-01-08       1.27151
## 10 2012-01-09       1.27272
## # ... with 1,817 more rows</code></pre>
<p>The data source is <a href="https://www.oanda.com/">Oanda</a>, and list of currencies to compare can be found on <a href="https://www.oanda.com/currency/converter/">Oanda’s currency converter</a>. It may make more sense to get this data from the FRED (See <a href="#economic-data">Economic Data</a>) since the max period for Oanda is 5-years.</p>
<p><strong>Metal Prices</strong>:</p>
<p>Metal prices are very similar to stock prices. Set <code>get = &quot;metal.prices&quot;</code> along with the appropriate commodity symbol (e.g. XAU (gold) , XAG (silver), XPD (palladium), or XPT (platinum)).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">plat_price_eur &lt;-<span class="st"> </span><span class="kw">tq_get</span>(<span class="st">&quot;plat&quot;</span>, <span class="dt">get =</span> <span class="st">&quot;metal.prices&quot;</span>, 
                         <span class="dt">from =</span> <span class="st">&quot;2000-01-01&quot;</span>, <span class="dt">base.currency =</span> <span class="st">&quot;EUR&quot;</span>)
plat_price_eur </code></pre></div>
<pre><code>## # A tibble: 1,827 × 2
##          date   price
##        &lt;date&gt;   &lt;dbl&gt;
## 1  2011-12-31 1080.87
## 2  2012-01-01 1081.11
## 3  2012-01-02 1085.99
## 4  2012-01-03 1080.45
## 5  2012-01-04 1080.47
## 6  2012-01-05 1091.55
## 7  2012-01-06 1100.26
## 8  2012-01-07 1104.61
## 9  2012-01-08 1097.12
## 10 2012-01-09 1096.08
## # ... with 1,817 more rows</code></pre>
<p>The data source is <a href="https://www.oanda.com/">Oanda</a>. It may make more sense to get this data from the FRED (See <a href="#economic-data">Economic Data</a>) since the max period for Oanda is 5-years.</p>
<p><a class="anchor" id="tq-transform"></a></p>
</div>
<div id="transform-and-mutate-quantitative-data" class="section level3">
<h3>Transform and Mutate Quantitative Data</h3>
<p>Transform and mutate functions enable the <code>xts</code>, <code>quantmod</code> and <code>TTR</code> functions to shine (see <a href="#quant-power">Leverage the Quantitative Power of <code>xts</code>, <code>quantmod</code> and <code>TTR</code></a>):</p>
<p><strong>Transform Quantitative Data, <code>tq_transform()</code></strong>:</p>
<p>Transforms the results of <code>tq_get()</code>. The result is typically a different shape than the input (hence “transformed”), although this is not a requirement. An example is periodicity aggregation from daily to monthly.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fb_prices &lt;-<span class="st"> </span><span class="kw">tq_get</span>(<span class="st">&quot;FB&quot;</span>) 
fb_prices %&gt;%
<span class="st">    </span><span class="kw">tq_transform</span>(<span class="dt">x_fun =</span> OHLCV, <span class="dt">transform_fun =</span> to.monthly)</code></pre></div>
<pre><code>## # A tibble: 56 × 6
##        date  open  high   low close    volume
##       &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;
## 1  May 2012 28.55 29.67 26.83 29.60 111639200
## 2  Jun 2012 31.92 31.99 30.76 31.10  19526900
## 3  Jul 2012 23.37 23.37 21.61 21.71  56179400
## 4  Aug 2012 18.68 18.70 18.03 18.06  58764200
## 5  Sep 2012 20.57 21.95 20.50 21.66  65486000
## 6  Oct 2012 20.82 21.50 20.73 21.11  99378200
## 7  Nov 2012 27.26 28.00 26.76 28.00 127049600
## 8  Dec 2012 26.20 26.99 26.11 26.62  60374500
## 9  Jan 2013 29.15 31.47 28.74 30.98 190744900
## 10 Feb 2013 26.84 27.30 26.34 27.25  83027800
## # ... with 46 more rows</code></pre>
<p>Let’s go through what happened. <code>x_fun</code> is one of the various quantmod Open, High, Low, Close (OHLC) functions (see <code>?quantmod::OHLC</code>). The function returns a column or set of columns from data that are passed to the <code>transform_fun</code>. In example above, <code>OHLCV</code> selects the full list of prices and volumes from <code>data</code>, and sends this to the transform function, <code>to.monthly</code>, which transforms the periodicity from daily to monthly. Additional arguments can be passed to the <code>transform_fun</code> by way of <code>...</code>.</p>
<p><strong>Mutate Quantitative Data, <code>tq_mutate()</code></strong>:</p>
<p>Adds a column or set of columns to the tibble with the calculated attributes (hence the original tibble is returned, mutated with the additional columns). An example is getting the <code>MACD</code> from <code>Cl</code> (close price), which mutates the original input by adding MACD and Signal columns.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fb_prices %&gt;%
<span class="st">    </span><span class="kw">tq_mutate</span>(<span class="dt">x_fun =</span> Cl, <span class="dt">mutate_fun =</span> MACD)</code></pre></div>
<pre><code>## # A tibble: 1,163 × 9
##          date  open  high   low close    volume adjusted  macd signal
##        &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
## 1  2012-05-18 42.05 45.00 38.00 38.23 573576400    38.23    NA     NA
## 2  2012-05-21 36.53 36.66 33.00 34.03 168192700    34.03    NA     NA
## 3  2012-05-22 32.61 33.59 30.94 31.00 101786600    31.00    NA     NA
## 4  2012-05-23 31.37 32.50 31.36 32.00  73600000    32.00    NA     NA
## 5  2012-05-24 32.95 33.21 31.77 33.03  50237200    33.03    NA     NA
## 6  2012-05-25 32.90 32.95 31.11 31.91  37149800    31.91    NA     NA
## 7  2012-05-29 31.48 31.69 28.65 28.84  78063400    28.84    NA     NA
## 8  2012-05-30 28.70 29.55 27.86 28.19  57267900    28.19    NA     NA
## 9  2012-05-31 28.55 29.67 26.83 29.60 111639200    29.60    NA     NA
## 10 2012-06-01 28.89 29.15 27.39 27.72  41855500    27.72    NA     NA
## # ... with 1,153 more rows</code></pre>
<p>Note that a mutation can occur if, and only if, the mutation has the same structure of the original tibble. In other words, the calculation must have the same number of rows and row.names (or date fields), otherwise the mutation cannot be performed.</p>
<p><strong>xy Variants, <code>tq_transform_xy</code> and <code>tq_mutate_xy</code></strong>:</p>
<p>Enables working with:</p>
<ol style="list-style-type: decimal">
<li>Transformation functions that require two primary inputs (e.g. EVWMA, VWAP, etc)</li>
<li>Data that is not in OHLC format.</li>
</ol>
<p><em>Transformation with two primary inputs</em>:</p>
<p>EVWMA (exponential volume-weighted moving average) requires two inputs, price and volume, that are not in OHLC code format. To work with these columns, we can switch to the xy variants, <code>tq_transform_xy()</code> and <code>tq_mutate_xy()</code>. The only difference is instead of an <code>x_fun</code> argument, you use <code>.x</code> and <code>.y</code> arguments to pass the columns needed based on the <code>transform_fun</code> or <code>mutate_fun</code> documentation.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fb_prices %&gt;%
<span class="st">    </span><span class="kw">tq_mutate_xy</span>(<span class="dt">.x =</span> close, <span class="dt">.y =</span> volume, <span class="dt">mutate_fun =</span> EVWMA)</code></pre></div>
<pre><code>## # A tibble: 1,163 × 8
##          date  open  high   low close    volume adjusted    V1
##        &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;
## 1  2012-05-18 42.05 45.00 38.00 38.23 573576400    38.23    NA
## 2  2012-05-21 36.53 36.66 33.00 34.03 168192700    34.03    NA
## 3  2012-05-22 32.61 33.59 30.94 31.00 101786600    31.00    NA
## 4  2012-05-23 31.37 32.50 31.36 32.00  73600000    32.00    NA
## 5  2012-05-24 32.95 33.21 31.77 33.03  50237200    33.03    NA
## 6  2012-05-25 32.90 32.95 31.11 31.91  37149800    31.91    NA
## 7  2012-05-29 31.48 31.69 28.65 28.84  78063400    28.84    NA
## 8  2012-05-30 28.70 29.55 27.86 28.19  57267900    28.19    NA
## 9  2012-05-31 28.55 29.67 26.83 29.60 111639200    29.60    NA
## 10 2012-06-01 28.89 29.15 27.39 27.72  41855500    27.72 27.72
## # ... with 1,153 more rows</code></pre>
<p><em>Working with non-OHLC data</em>:</p>
<p>Returns from FRED, Oanda, and other sources do not have open, high, low, close, and volume (OHLCV) format. The following example shows how to transform WTI Crude daily prices to monthly prices. Since we only have a single column to pass, set the <code>.x = price</code> and leave the <code>.y = NULL</code>. This sends the price column to the <code>to.period</code> transformation fuction.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">wti_prices &lt;-<span class="st"> </span><span class="kw">tq_get</span>(<span class="st">&quot;DCOILWTICO&quot;</span>, <span class="dt">get =</span> <span class="st">&quot;economic.data&quot;</span>) 
wti_prices %&gt;%<span class="st">    </span>
<span class="st">    </span><span class="kw">tq_transform_xy</span>(<span class="dt">.x =</span> price, <span class="dt">transform_fun =</span> to.period,
                    <span class="dt">period =</span> <span class="st">&quot;months&quot;</span>)</code></pre></div>
<pre><code>## # A tibble: 132 × 2
##          date price
##        &lt;dttm&gt; &lt;dbl&gt;
## 1  2006-01-31 67.86
## 2  2006-02-28 61.37
## 3  2006-03-31 66.25
## 4  2006-04-28 71.80
## 5  2006-05-31 71.42
## 6  2006-06-30 73.94
## 7  2006-07-31 74.56
## 8  2006-08-31 70.38
## 9  2006-09-29 62.90
## 10 2006-10-31 58.72
## # ... with 122 more rows</code></pre>
<p><a class="anchor" id="tq-coerce"></a></p>
</div>
<div id="coercing-time-series-objects-to-and-from-tibble" class="section level3">
<h3>Coercing Time Series Objects To and From Tibble</h3>
<p>Sometimes you want to work using a <code>tibble</code> and other times you want to work using a <code>xts</code> object. The <code>as_tibble()</code> and <code>as_xts()</code> functions are the key.</p>
<p><strong>Coerce from time-series to tibble, <code>as_tibble()</code></strong>:</p>
<p>The <code>tidyquant::as_tibble()</code> function includes a <code>preserve_row_names</code> argument, which is useful when coercing one of the many time formats (e.g. <code>xts</code>, <code>zoo</code>, <code>timeSeries</code>, <code>ts</code>) or <code>matrix</code> objects that contain valuable information in the row names. This makes bridging the gap between the various quantitative analysis packages and the <code>tidyverse</code> much easier.</p>
<p>Let’s start with an <code>xts</code> object.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Create xts object from a matrix</span>
vals =<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">500</span>, <span class="dv">504</span>, <span class="dv">503</span>))
date =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;2016-01-01&quot;</span>, <span class="st">&quot;2016-01-02&quot;</span>, <span class="st">&quot;2016-01-03&quot;</span>) 
<span class="kw">rownames</span>(vals) &lt;-<span class="st"> </span>date
time_series_xts &lt;-<span class="st"> </span><span class="kw">as_xts</span>(vals)
time_series_xts</code></pre></div>
<pre><code>##            [,1]
## 2016-01-01  500
## 2016-01-02  504
## 2016-01-03  503</code></pre>
<p>We can easily coerce to <code>tibble</code> by setting <code>preserve_row_names = TRUE</code>. Note the return column is <code>row.names</code> with class of <code>character</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">time_series_tbl &lt;-<span class="st"> </span><span class="kw">as_tibble</span>(time_series_xts, <span class="dt">preserve_row_names =</span> <span class="ot">TRUE</span>)
time_series_tbl</code></pre></div>
<pre><code>## # A tibble: 3 × 2
##    row.names    V1
##        &lt;chr&gt; &lt;dbl&gt;
## 1 2016-01-01   500
## 2 2016-01-02   504
## 3 2016-01-03   503</code></pre>
<p>Converting to date is one extra step with <code>lubridate</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">time_series_tbl &lt;-<span class="st"> </span>time_series_tbl %&gt;%
<span class="st">    </span><span class="kw">mutate</span>(<span class="dt">row.names =</span> lubridate::<span class="kw">ymd</span>(row.names))
time_series_tbl</code></pre></div>
<pre><code>## # A tibble: 3 × 2
##    row.names    V1
##       &lt;date&gt; &lt;dbl&gt;
## 1 2016-01-01   500
## 2 2016-01-02   504
## 3 2016-01-03   503</code></pre>
<p><strong>Coerce from tibble to xts, <code>as_xts()</code></strong>:</p>
<p>We can convert back to <code>xts</code> with the tidyquant <code>as_xts()</code> function. Make sure to set the date column (<code>date_col</code>) argument to the column name containing the date (<code>date_col = row.names</code>). The date column must be in a date format (inherits either <code>Date</code> or <code>POSIXct</code> classes).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">time_series_xts &lt;-<span class="st"> </span>time_series_tbl %&gt;%
<span class="st">    </span><span class="kw">as_xts</span>(<span class="dt">date_col =</span> row.names)
time_series_xts</code></pre></div>
<pre><code>##             V1
## 2016-01-01 500
## 2016-01-02 504
## 2016-01-03 503</code></pre>
<p><a class="anchor" id="tidyverse"></a></p>
</div>
</div>
<div id="working-in-the-tidyverse" class="section level2">
<h2>Working in the tidyverse</h2>
<p>You probably already know and love <code>tidyverse</code> packages like <code>dplyr</code>, <code>tidyr</code>, <code>purrr</code>, <code>readr</code>, and <code>tibble</code> along with <code>lubridate</code> for working with date and datetime. <code>tidyquant</code> works solely in tibbles, so all of the <code>tidyverse</code> functionality is intact.</p>
<p>A simple example inspired by <a href="https://blog.exploratory.io/introducing-time-series-analysis-with-dplyr-60683587cf8a#.w6pvyi3d2">Kan Nishida’s blog</a> shows the <code>dplyr</code> and <code>lubridate</code> capability: Say we want the growth in the stock over the past year. We can do this with <code>dplyr</code> operations.</p>
<p>Getting the last year is simple with <code>dplyr</code> and <code>lubridate</code>. We first <code>select</code> the date and adjusted price (adjusted for stock splits). We then <code>filter</code> using <code>lubridate</code> date functions.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">aapl_prices %&gt;%
<span class="st">    </span><span class="kw">select</span>(date, adjusted) %&gt;%
<span class="st">    </span><span class="kw">filter</span>(date &gt;=<span class="st"> </span><span class="kw">today</span>() -<span class="st"> </span><span class="kw">years</span>(<span class="dv">1</span>))</code></pre></div>
<pre><code>## # A tibble: 253 × 2
##          date  adjusted
##        &lt;date&gt;     &lt;dbl&gt;
## 1  2015-12-31 102.96903
## 2  2016-01-04 103.05706
## 3  2016-01-05 100.47452
## 4  2016-01-06  98.50827
## 5  2016-01-07  94.35077
## 6  2016-01-08  94.84967
## 7  2016-01-11  96.38550
## 8  2016-01-12  97.78438
## 9  2016-01-13  95.27031
## 10 2016-01-14  97.35395
## # ... with 243 more rows</code></pre>
<p>We can also get a baseline price using the <code>first</code> function. Adding to our workflow, this looks like:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">aapl_prices %&gt;%
<span class="st">    </span><span class="kw">select</span>(date, adjusted) %&gt;%
<span class="st">    </span><span class="kw">filter</span>(date &gt;=<span class="st"> </span><span class="kw">today</span>() -<span class="st"> </span><span class="kw">years</span>(<span class="dv">1</span>)) %&gt;%
<span class="st">    </span><span class="kw">mutate</span>(<span class="dt">baseline =</span> <span class="kw">first</span>(adjusted))</code></pre></div>
<pre><code>## # A tibble: 253 × 3
##          date  adjusted baseline
##        &lt;date&gt;     &lt;dbl&gt;    &lt;dbl&gt;
## 1  2015-12-31 102.96903  102.969
## 2  2016-01-04 103.05706  102.969
## 3  2016-01-05 100.47452  102.969
## 4  2016-01-06  98.50827  102.969
## 5  2016-01-07  94.35077  102.969
## 6  2016-01-08  94.84967  102.969
## 7  2016-01-11  96.38550  102.969
## 8  2016-01-12  97.78438  102.969
## 9  2016-01-13  95.27031  102.969
## 10 2016-01-14  97.35395  102.969
## # ... with 243 more rows</code></pre>
<p>Growth and growth percent versus baseline columns can be added now. We tack on a final select statement to remove unnecessary columns. The final workflow looks like this:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">aapl_prices %&gt;%
<span class="st">    </span><span class="kw">select</span>(date, adjusted) %&gt;%
<span class="st">    </span><span class="kw">filter</span>(date &gt;=<span class="st"> </span><span class="kw">today</span>() -<span class="st"> </span><span class="kw">years</span>(<span class="dv">1</span>)) %&gt;%
<span class="st">    </span><span class="kw">mutate</span>(<span class="dt">baseline =</span> <span class="kw">first</span>(adjusted),
           <span class="dt">growth =</span> adjusted -<span class="st"> </span>baseline,
           <span class="dt">growth_pct =</span> growth /<span class="st"> </span>baseline *<span class="st"> </span><span class="dv">100</span>) %&gt;%
<span class="st">    </span><span class="kw">select</span>(-(baseline:growth))</code></pre></div>
<pre><code>## # A tibble: 253 × 3
##          date  adjusted growth_pct
##        &lt;date&gt;     &lt;dbl&gt;      &lt;dbl&gt;
## 1  2015-12-31 102.96903  0.0000000
## 2  2016-01-04 103.05706  0.0854995
## 3  2016-01-05 100.47452 -2.4225751
## 4  2016-01-06  98.50827 -4.3321348
## 5  2016-01-07  94.35077 -8.3697559
## 6  2016-01-08  94.84967 -7.8852393
## 7  2016-01-11  96.38550 -6.3936946
## 8  2016-01-12  97.78438 -5.0351540
## 9  2016-01-13  95.27031 -7.4767271
## 10 2016-01-14  97.35395 -5.4531690
## # ... with 243 more rows</code></pre>
<p><a class="anchor" id="quant-power"></a></p>
</div>
<div id="leverage-the-quantitative-power-of-xts-quantmod-and-ttr" class="section level2">
<h2>Leverage the Quantitative Power of xts, quantmod and TTR</h2>
<p>You may already know and love <code>xts</code>, <code>quantmod</code> and <code>TTR</code>, which is why the core functionality is fully intact. Using <code>tq_transform()</code> and <code>tq_mutate()</code>, we can apply the <code>xts</code>, <code>quantmod</code> and <code>TTR</code> functions. Entering <code>tq_transform_fun_options()</code> returns a list the transform functions by each package. We’ll discuss these options by package briefly.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tq_transform_fun_options</span>() %&gt;%<span class="st"> </span><span class="kw">str</span>()</code></pre></div>
<pre><code>## List of 3
##  $ xts     : chr [1:27] &quot;apply.daily&quot; &quot;apply.monthly&quot; &quot;apply.quarterly&quot; &quot;apply.weekly&quot; ...
##  $ quantmod: chr [1:25] &quot;allReturns&quot; &quot;annualReturn&quot; &quot;ClCl&quot; &quot;dailyReturn&quot; ...
##  $ TTR     : chr [1:61] &quot;adjRatios&quot; &quot;ADX&quot; &quot;ALMA&quot; &quot;aroon&quot; ...</code></pre>
<div id="xts-functionality" class="section level3">
<h3>xts Functionality</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Get xts functions that work with tq_transform and tq_mutate</span>
<span class="kw">tq_transform_fun_options</span>()$xts</code></pre></div>
<pre><code>##  [1] &quot;apply.daily&quot;     &quot;apply.monthly&quot;   &quot;apply.quarterly&quot;
##  [4] &quot;apply.weekly&quot;    &quot;apply.yearly&quot;    &quot;diff.xts&quot;       
##  [7] &quot;lag.xts&quot;         &quot;period.apply&quot;    &quot;period.max&quot;     
## [10] &quot;period.min&quot;      &quot;period.prod&quot;     &quot;period.sum&quot;     
## [13] &quot;periodicity&quot;     &quot;to.daily&quot;        &quot;to.hourly&quot;      
## [16] &quot;to.minutes&quot;      &quot;to.minutes10&quot;    &quot;to.minutes15&quot;   
## [19] &quot;to.minutes3&quot;     &quot;to.minutes30&quot;    &quot;to.minutes5&quot;    
## [22] &quot;to.monthly&quot;      &quot;to.period&quot;       &quot;to.quarterly&quot;   
## [25] &quot;to.weekly&quot;       &quot;to.yearly&quot;       &quot;to_period&quot;</code></pre>
<p>The <code>xts</code> functions that are compatible are listed above. Generally speaking, these are the:</p>
<ul>
<li>Period Apply Functions:
<ul>
<li>Apply a function to a time segment (e.g. <code>max</code>, <code>min</code>, <code>mean</code>, etc).</li>
<li>Form: <code>apply.daily(x, FUN, ...)</code>.</li>
<li>Options include apply.daily, weekly, monthly, quarterly, yearly.</li>
</ul></li>
<li>To-Period Functions:
<ul>
<li>Convert a time series to time series of lower periodicity (e.g. convert daily to monthly periodicity).</li>
<li>Form: <code>to.period(x, period = 'months', k = 1, indexAt, name = NULL, OHLC = TRUE, ...)</code>.</li>
<li>Options include to.minutes, hourly, daily, weekly, monthly, quarterly, yearly.</li>
<li><strong>Note 1 (Important)</strong>: The return structure is different for <code>to.period</code> and the <code>to.monthly</code> (<code>to.weekly</code>, <code>to.quarterly</code>, etc) forms. <code>to.period</code> returns a date, while <code>to.months</code> returns a character MON YYYY. Best to use <code>to.period</code> if you want to work with time-series via <code>lubridate</code>.</li>
</ul></li>
</ul>
</div>
<div id="quantmod-functionality" class="section level3">
<h3>quantmod Functionality</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Get quantmod functions that work with tq_transform and tq_mutate</span>
<span class="kw">tq_transform_fun_options</span>()$quantmod</code></pre></div>
<pre><code>##  [1] &quot;allReturns&quot;      &quot;annualReturn&quot;    &quot;ClCl&quot;           
##  [4] &quot;dailyReturn&quot;     &quot;Delt&quot;            &quot;HiCl&quot;           
##  [7] &quot;Lag&quot;             &quot;LoCl&quot;            &quot;LoHi&quot;           
## [10] &quot;monthlyReturn&quot;   &quot;Next&quot;            &quot;OpCl&quot;           
## [13] &quot;OpHi&quot;            &quot;OpLo&quot;            &quot;OpOp&quot;           
## [16] &quot;periodReturn&quot;    &quot;quarterlyReturn&quot; &quot;seriesAccel&quot;    
## [19] &quot;seriesDecel&quot;     &quot;seriesDecr&quot;      &quot;seriesHi&quot;       
## [22] &quot;seriesIncr&quot;      &quot;seriesLo&quot;        &quot;weeklyReturn&quot;   
## [25] &quot;yearlyReturn&quot;</code></pre>
<p>The <code>quantmod</code> functions that are compatible are listed above. Generally speaking, these are the:</p>
<ul>
<li>Percentage Change (Delt) and Lag Functions
<ul>
<li>Delt: <code>Delt(x1, x2 = NULL, k = 0, type = c(&quot;arithmetic&quot;, &quot;log&quot;))</code>
<ul>
<li>Variations of Delt: ClCl, HiCl, LoCl, LoHi, OpCl, OpHi, OpLo, OpOp</li>
<li>Form: <code>OpCl(OHLC)</code></li>
</ul></li>
<li>Lag: <code>Lag(x, k = 1)</code> / Next: <code>Next(x, k = 1)</code> (Can also use <code>dplyr::lag</code> and <code>dplyr::lead</code>)</li>
</ul></li>
<li>Period Return Functions:
<ul>
<li>Get the arithmetic or logarithmic returns for various periodicities, which include daily, weekly, monthly, quarterly, and yearly.</li>
<li>Form: <code>periodReturn(x, period = 'monthly', subset = NULL, type = 'arithmetic', leading = TRUE, ...)</code></li>
</ul></li>
<li>Series Functions:
<ul>
<li>Return values that describe the series. Options include describing the increases/decreases, accelerations/decelerations, and hi/low.</li>
<li>Forms: <code>seriesHi(x)</code>, <code>seriesIncr(x, thresh = 0, diff. = 1L)</code>, <code>seriesAccel(x)</code></li>
</ul></li>
</ul>
</div>
<div id="ttr-functionality" class="section level3">
<h3>TTR Functionality</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Get TTR functions that work with tq_transform and tq_mutate</span>
<span class="kw">tq_transform_fun_options</span>()$TTR</code></pre></div>
<pre><code>##  [1] &quot;adjRatios&quot;          &quot;ADX&quot;                &quot;ALMA&quot;              
##  [4] &quot;aroon&quot;              &quot;ATR&quot;                &quot;BBands&quot;            
##  [7] &quot;CCI&quot;                &quot;chaikinAD&quot;          &quot;chaikinVolatility&quot; 
## [10] &quot;CLV&quot;                &quot;CMF&quot;                &quot;CMO&quot;               
## [13] &quot;DEMA&quot;               &quot;DonchianChannel&quot;    &quot;DPO&quot;               
## [16] &quot;DVI&quot;                &quot;EMA&quot;                &quot;EMV&quot;               
## [19] &quot;EVWMA&quot;              &quot;GMMA&quot;               &quot;growth&quot;            
## [22] &quot;HMA&quot;                &quot;KST&quot;                &quot;lags&quot;              
## [25] &quot;MACD&quot;               &quot;MFI&quot;                &quot;momentum&quot;          
## [28] &quot;OBV&quot;                &quot;PBands&quot;             &quot;ROC&quot;               
## [31] &quot;rollSFM&quot;            &quot;RSI&quot;                &quot;runCor&quot;            
## [34] &quot;runCov&quot;             &quot;runMAD&quot;             &quot;runMax&quot;            
## [37] &quot;runMean&quot;            &quot;runMedian&quot;          &quot;runMin&quot;            
## [40] &quot;runPercentRank&quot;     &quot;runSD&quot;              &quot;runSum&quot;            
## [43] &quot;runVar&quot;             &quot;SAR&quot;                &quot;SMA&quot;               
## [46] &quot;SMI&quot;                &quot;stoch&quot;              &quot;TDI&quot;               
## [49] &quot;TRIX&quot;               &quot;ultimateOscillator&quot; &quot;VHF&quot;               
## [52] &quot;VMA&quot;                &quot;volatility&quot;         &quot;VWAP&quot;              
## [55] &quot;VWMA&quot;               &quot;wilderSum&quot;          &quot;williamsAD&quot;        
## [58] &quot;WMA&quot;                &quot;WPR&quot;                &quot;ZigZag&quot;            
## [61] &quot;ZLEMA&quot;</code></pre>
<p>Here’ a brief description of the most popular functions from <code>TTR</code>:</p>
<ul>
<li>Welles Wilder’s Directional Movement Index:
<ul>
<li><code>ADX(HLC, n = 14, maType, ...)</code></li>
</ul></li>
<li>Bollinger Bands:
<ul>
<li><code>BBands(HLC, n = 20, maType, sd = 2, ...)</code>: Bollinger Bands</li>
</ul></li>
<li>Rate of Change / Momentum:
<ul>
<li><code>ROC(x, n = 1, type = c(&quot;continuous&quot;, &quot;discrete&quot;), na.pad = TRUE)</code>: Rate of Change</li>
<li><code>momentum(x, n = 1, na.pad = TRUE)</code>: Momentum</li>
</ul></li>
<li>Moving Averages (maType):
<ul>
<li><code>SMA(x, n = 10, ...)</code>: Simple Moving Average</li>
<li><code>EMA(x, n = 10, wilder = FALSE, ratio = NULL, ...)</code>: Exponential Moving Average</li>
<li><code>DEMA(x, n = 10, v = 1, wilder = FALSE, ratio = NULL)</code>: Double Exponential Moving Average</li>
<li><code>WMA(x, n = 10, wts = 1:n, ...)</code>: Weighted Moving Average</li>
<li><code>EVWMA(price, volume, n = 10, ...)</code>: Elastic, Volume-Weighted Moving Average</li>
<li><code>ZLEMA(x, n = 10, ratio = NULL, ...)</code>: Zero Lag Exponential Moving Average</li>
<li><code>VWAP(price, volume, n = 10, ...)</code>: Volume-Weighted Moving Average Price</li>
<li><code>VMA(x, w, ratio = 1, ...)</code>: Variable-Length Moving Average</li>
<li><code>HMA(x, n = 20, ...)</code>: Hull Moving Average</li>
<li><code>ALMA(x, n = 9, offset = 0.85, sigma = 6, ...)</code>: Arnaud Legoux Moving Average</li>
</ul></li>
<li>MACD Oscillator:
<ul>
<li><code>MACD(x, nFast = 12, nSlow = 26, nSig = 9, maType, percent = TRUE, ...)</code></li>
</ul></li>
<li>Relative Strength Index:
<ul>
<li><code>RSI(price, n = 14, maType, ...)</code></li>
</ul></li>
<li>runFun:
<ul>
<li><code>runSum(x, n = 10, cumulative = FALSE)</code>: returns sums over a n-period moving window.</li>
<li><code>runMin(x, n = 10, cumulative = FALSE)</code>: returns minimums over a n-period moving window.</li>
<li><code>runMax(x, n = 10, cumulative = FALSE)</code>: returns maximums over a n-period moving window.</li>
<li><code>runMean(x, n = 10, cumulative = FALSE)</code>: returns means over a n-period moving window.</li>
<li><code>runMedian(x, n = 10, non.unique = &quot;mean&quot;, cumulative = FALSE)</code>: returns medians over a n-period moving window.</li>
<li><code>runCov(x, y, n = 10, use = &quot;all.obs&quot;, sample = TRUE, cumulative = FALSE)</code>: returns covariances over a n-period moving window.</li>
<li><code>runCor(x, y, n = 10, use = &quot;all.obs&quot;, sample = TRUE, cumulative = FALSE)</code>: returns correlations over a n-period moving window.</li>
<li><code>runVar(x, y = NULL, n = 10, sample = TRUE, cumulative = FALSE)</code>: returns variances over a n-period moving window.</li>
<li><code>runSD(x, n = 10, sample = TRUE, cumulative = FALSE)</code>: returns standard deviations over a n-period moving window.</li>
<li><code>runMAD(x, n = 10, center = NULL, stat = &quot;median&quot;, constant = 1.4826, non.unique = &quot;mean&quot;, cumulative = FALSE)</code>: returns median/mean absolute deviations over a n-period moving window.</li>
<li><code>wilderSum(x, n = 10)</code>: retuns a Welles Wilder style weighted sum over a n-period moving window.</li>
</ul></li>
<li>Stochastic Oscillator / Stochastic Momentum Index:
<ul>
<li><code>stoch(HLC, nFastK = 14, nFastD = 3, nSlowD = 3, maType, bounded = TRUE, smooth = 1, ...)</code>: Stochastic Oscillator</li>
<li><code>SMI(HLC, n = 13, nFast = 2, nSlow = 25, nSig = 9, maType, bounded = TRUE, ...)</code>: Stochastic Momentum Index</li>
</ul></li>
</ul>
</div>
<div id="quantitative-power-in-action" class="section level3">
<h3>Quantitative Power In Action</h3>
<p>We’ll go through some examples, but first let’s get some data. The default for <code>tq_get()</code> is <code>get = &quot;stock.prices&quot;</code>, so all we need is to give <code>x</code> a stock symbol.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">AAPL &lt;-<span class="st"> </span><span class="kw">tq_get</span>(<span class="st">&quot;AAPL&quot;</span>)</code></pre></div>
<div id="example-1-getting-the-max-close-price-for-each-quarter." class="section level4">
<h4>Example 1: Getting the max close price for each quarter.</h4>
<p>The <code>xts::apply.quarterly()</code> function that is part of the period apply group can be used to apply functions by quarterly time segments. Because we are seeking a return structure that is on a different time scale than the input (quarterly versus daily), we need to use a transform function. We select <code>tq_transform</code> and pass the close price using OHLC format via <code>x_fun = Cl</code>, and we send this subset of the data to the <code>apply.quarterly</code> function via the <code>transform_fun</code> argument. Looking at the documentation for <code>apply.quarterly</code>, we see that we can pass a function to the argument, <code>FUN</code>. We want the maximum values, so we set <code>FUN = max</code>. The result is the quarters returned as a date and the maximum closing price during the quarter returned as a double.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">AAPL %&gt;%
<span class="st">    </span><span class="kw">tq_transform</span>(<span class="dt">x_fun =</span> Cl, <span class="dt">transform_fun =</span> apply.quarterly, <span class="dt">FUN =</span> max)</code></pre></div>
<pre><code>## # A tibble: 44 × 2
##          date  close
##        &lt;dttm&gt;  &lt;dbl&gt;
## 1  2006-03-31  85.59
## 2  2006-06-30  71.89
## 3  2006-09-29  77.61
## 4  2006-12-29  91.81
## 5  2007-03-30  97.10
## 6  2007-06-29 125.09
## 7  2007-09-28 154.50
## 8  2007-12-31 199.83
## 9  2008-03-31 194.93
## 10 2008-06-30 189.96
## # ... with 34 more rows</code></pre>
<p>Note that as an alternative you could use the xy form, replacing <code>x_fun = Cl</code> with <code>.x = close</code>.</p>
</div>
<div id="example-2-getting-daily-log-returns" class="section level4">
<h4>Example 2: Getting daily log returns</h4>
<p>The <code>quantmod::periodReturn()</code> function generates returns by periodicity. We have a few options here. Normally I go with a transform function, <code>tq_transform</code>, because the <code>periodReturn</code> function accepts different periodicity options, and anything other than daily will blow up a mutation. But, in our situation the period returns periodicity is the same as the stock prices periodicity (both daily), so we can use either. We want to use the adjusted closing prices column (adjusted for stock splits, which can make it appear that a stock is performing poorly if a split is included), so we set <code>x_fun = Ad</code>. We researched the <code>periodReturn</code> function, and we found that it accepts <code>type = &quot;log&quot;</code> and <code>period = &quot;daily&quot;</code>, which returns the daily log returns.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">AAPL %&gt;%
<span class="st">    </span><span class="kw">tq_transform</span>(<span class="dt">x_fun =</span> Ad, <span class="dt">transform_fun =</span> periodReturn, 
                 <span class="dt">type =</span> <span class="st">&quot;log&quot;</span>, <span class="dt">period =</span> <span class="st">&quot;daily&quot;</span>)</code></pre></div>
<pre><code>## # A tibble: 2,769 × 2
##          date daily.returns
##        &lt;dttm&gt;         &lt;dbl&gt;
## 1  2006-01-03   0.000000000
## 2  2006-01-04   0.002938752
## 3  2006-01-05  -0.007900889
## 4  2006-01-06   0.025485766
## 5  2006-01-09  -0.003281888
## 6  2006-01-10   0.061328315
## 7  2006-01-11   0.036906288
## 8  2006-01-12   0.004637594
## 9  2006-01-13   0.015305252
## 10 2006-01-17  -0.010334731
## # ... with 2,759 more rows</code></pre>
</div>
<div id="example-3-adding-macd-and-bollinger-bands-to-a-ohlc-data-set" class="section level4">
<h4>Example 3: Adding MACD and Bollinger Bands to a OHLC data set</h4>
<p>In reviewing the available options in the <code>TTR</code> package, we see that <code>MACD</code> and <code>BBands</code> functions will get us where we need to be. In researching the documentation, the return is in the same periodicity as the input and the functions work with OHLC functions, so we can use <code>tq_mutate()</code>. MACD requires a price, so we select close using <code>Cl</code>, BBands requires high, low, and close, prices so we use <code>HLC</code>. We can chain the inputs together using the pipe (<code>%&gt;%</code>) since mutate just adds columns. The result is a tibble containing the MACD and Bollinger Band results.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">AAPL %&gt;%
<span class="st">    </span><span class="kw">tq_mutate</span>(Cl, MACD) %&gt;%
<span class="st">    </span><span class="kw">tq_mutate</span>(HLC, BBands)</code></pre></div>
<pre><code>## # A tibble: 2,769 × 13
##          date  open  high   low close    volume  adjusted  macd signal
##        &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
## 1  2006-01-03 72.38 74.75 72.25 74.75 201808600  9.726565    NA     NA
## 2  2006-01-04 75.13 75.98 74.50 74.97 154900900  9.755191    NA     NA
## 3  2006-01-05 74.83 74.90 73.75 74.38 112355600  9.678420    NA     NA
## 4  2006-01-06 75.25 76.70 74.55 76.30 176114400  9.928252    NA     NA
## 5  2006-01-09 76.73 77.20 75.74 76.05 168760200  9.895722    NA     NA
## 6  2006-01-10 76.25 81.89 75.83 80.86 569967300 10.521606    NA     NA
## 7  2006-01-11 83.84 84.80 82.59 83.90 373448600 10.917174    NA     NA
## 8  2006-01-12 84.97 86.40 83.62 84.29 320202400 10.967921    NA     NA
## 9  2006-01-13 84.99 86.01 84.60 85.59 194076400 11.137079    NA     NA
## 10 2006-01-17 85.70 86.38 83.87 84.71 208905900 11.022573    NA     NA
## # ... with 2,759 more rows, and 4 more variables: dn &lt;dbl&gt;, mavg &lt;dbl&gt;,
## #   up &lt;dbl&gt;, pctB &lt;dbl&gt;</code></pre>
<p>Note that for the MACD, we could have used <code>tq_mutate_xy()</code>, setting <code>.x = close</code>. However, for the BBands, we are forced to use <code>tq_mutate()</code> because of the HLC input.</p>
</div>
<div id="example-4-getting-the-percentage-difference-between-open-and-close-from-zero-to-five-periods" class="section level4">
<h4>Example 4: Getting the Percentage Difference Between Open and Close from Zero to Five Periods</h4>
<p>We can’t use the <code>OpCl</code> function for this task since it only returns the percentage difference for a period lag of zero. We keep digging and we find the base <code>Delt</code> function from quantmod. In researching the function, we see that <code>Delt</code> takes one or two inputs, <code>k</code> a series of lags, and the type of difference, either arithmetic or log. We will set <code>.x = open</code> and <code>.y = close</code> and <code>k = 0:5</code> to get zero through five periods. The default <code>type = &quot;arithmetic&quot;</code> is acceptable, so there is no need to specify. The result is the percentage difference between the open and close prices for periods zero to five.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">AAPL %&gt;%
<span class="st">    </span><span class="kw">tq_mutate_xy</span>(<span class="dt">.x =</span> open, <span class="dt">.y =</span> close, <span class="dt">mutate_fun =</span> Delt, <span class="dt">k =</span> <span class="dv">0</span>:<span class="dv">5</span>) %&gt;%
<span class="st">    </span><span class="kw">select</span>(-<span class="kw">c</span>(high, low, volume, adjusted))</code></pre></div>
<pre><code>## # A tibble: 2,769 × 9
##          date  open close Delt.0.arithmetic Delt.1.arithmetic
##        &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt;             &lt;dbl&gt;             &lt;dbl&gt;
## 1  2006-01-03 72.38 74.75      0.0327438653                NA
## 2  2006-01-04 75.13 74.97     -0.0021296021       0.035783351
## 3  2006-01-05 74.83 74.38     -0.0060135910      -0.009982657
## 4  2006-01-06 75.25 76.30      0.0139534485       0.019644528
## 5  2006-01-09 76.73 76.05     -0.0088622703       0.010631203
## 6  2006-01-10 76.25 80.86      0.0604590009       0.053825127
## 7  2006-01-11 83.84 83.90      0.0007155892       0.100327799
## 8  2006-01-12 84.97 84.29     -0.0080028479       0.005367330
## 9  2006-01-13 84.99 85.59      0.0070596538       0.007296705
## 10 2006-01-17 85.70 84.71     -0.0115518788      -0.003294505
## # ... with 2,759 more rows, and 4 more variables: Delt.2.arithmetic &lt;dbl&gt;,
## #   Delt.3.arithmetic &lt;dbl&gt;, Delt.4.arithmetic &lt;dbl&gt;,
## #   Delt.5.arithmetic &lt;dbl&gt;</code></pre>
<p>For comparison we’ll inspect the output from the <code>OpCl()</code> function using <code>tq_mutate()</code>. We send OHLC prices to the OpCl function. As expected the <code>OpCl..</code> column returned is the same as <code>Delt.0.arithmetic</code> from above.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">AAPL %&gt;%
<span class="st">    </span><span class="kw">tq_mutate</span>(OHLC, OpCl) %&gt;%
<span class="st">    </span><span class="kw">select</span>(-<span class="kw">c</span>(high, low, volume, adjusted))</code></pre></div>
<pre><code>## # A tibble: 2,769 × 4
##          date  open close        OpCl..
##        &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt;         &lt;dbl&gt;
## 1  2006-01-03 72.38 74.75  0.0327438653
## 2  2006-01-04 75.13 74.97 -0.0021296021
## 3  2006-01-05 74.83 74.38 -0.0060135910
## 4  2006-01-06 75.25 76.30  0.0139534485
## 5  2006-01-09 76.73 76.05 -0.0088622703
## 6  2006-01-10 76.25 80.86  0.0604590009
## 7  2006-01-11 83.84 83.90  0.0007155892
## 8  2006-01-12 84.97 84.29 -0.0080028479
## 9  2006-01-13 84.99 85.59  0.0070596538
## 10 2006-01-17 85.70 84.71 -0.0115518788
## # ... with 2,759 more rows</code></pre>
<p><a class="anchor" id="built-for-scale"></a></p>
</div>
</div>
</div>
<div id="designed-to-be-used-and-scaled-with-the-tidyverse" class="section level2">
<h2>Designed to be Used and Scaled with the tidyverse</h2>
<p>Each function has one primary input and one output. This allows chaining operations with the pipe (<code>%&gt;%</code>), and mapping to extend to lists of many stocks, exchange rates, metals, economic data, financial statements, etc. The rationale behind this is simple: let the function handle the operation, let the <code>tidyverse</code> handle the iteration.</p>
<p>Rather than explain, let’s go through a simple workflow using the <code>tidyverse</code>. We setup a two step workflow:</p>
<ol style="list-style-type: decimal">
<li>Analyze a single stock</li>
<li>Scale to many stocks</li>
</ol>
<div id="analyze-a-single-stock" class="section level4">
<h4>Analyze a Single Stock</h4>
<p>In our hypothetical situation, we want to compare the mean monthly log returns (MMLR). First, let’s come up with a function to help us collect log returns. The function below performs three operations internally. It first gets the stock prices using <code>tq_get()</code>. Then, it transforms the stock prices to period returns using <code>tq_transform()</code>. We add the <code>type = &quot;log&quot;</code> and <code>period = &quot;monthly&quot;</code> arguments to ensure we retrieve a tibble of monthly log returns. Last, we take the mean of the monthly returns to get MMLR.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">my_stock_analysis_fun &lt;-<span class="st"> </span>function(stock.symbol) {
    period.returns &lt;-<span class="st"> </span>stock.symbol %&gt;%
<span class="st">        </span><span class="kw">tq_get</span>(<span class="dt">get =</span> <span class="st">&quot;stock.prices&quot;</span>) %&gt;%
<span class="st">        </span><span class="kw">tq_transform</span>(<span class="dt">x_fun =</span> Ad, <span class="dt">transform_fun =</span> periodReturn, 
                     <span class="dt">type =</span> <span class="st">&quot;log&quot;</span>, <span class="dt">period =</span> <span class="st">&quot;monthly&quot;</span>)
    <span class="kw">mean</span>(period.returns$monthly.returns)
}</code></pre></div>
<p>And, let’s test it out. We now have the mean monthly log returns over the past ten years.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">my_stock_analysis_fun</span>(<span class="st">&quot;AAPL&quot;</span>)</code></pre></div>
<pre><code>## [1] 0.01876649</code></pre>
</div>
<div id="extrapolate-to-many-stocks-using-tidyverse" class="section level3">
<h3>Extrapolate to Many Stocks using <code>tidyverse</code></h3>
<p>Now that we have one stock down, we can scale to many stocks. For brevity, we’ll randomly sample ten stocks from the S&amp;P500 with a call to <code>dplyr::sample_n()</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">100</span>)
stocks &lt;-<span class="st"> </span><span class="kw">tq_get</span>(<span class="st">&quot;SP500&quot;</span>, <span class="dt">get =</span> <span class="st">&quot;stock.index&quot;</span>) %&gt;%
<span class="st">    </span><span class="kw">sample_n</span>(<span class="dv">10</span>)
stocks</code></pre></div>
<pre><code>## # A tibble: 10 × 2
##    symbol            company
##     &lt;chr&gt;              &lt;chr&gt;
## 1     EMC                EMC
## 2    XRAY      DENTSPLY INTL
## 3     MNK   MALLINCKRODT PLC
## 4     AIG      AMERICAN INTL
## 5    INTC              INTEL
## 6     IVZ            INVESCO
## 7      SE     SPECTRA ENERGY
## 8    FLIR       FLIR SYSTEMS
## 9       L              LOEWS
## 10    CNP CENTERPOINT ENERGY</code></pre>
<p>We can now apply our analysis function to the stocks using <code>dplyr::mutate</code> and <code>purrr::map_dbl</code>. The <code>mutate()</code> function adds a column to our tibble, and the <code>map_dbl()</code> function maps our <code>my_stock_analysis_fun</code> to our tibble of stocks using the <code>symbol</code> column.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">stocks &lt;-<span class="st"> </span>stocks %&gt;%
<span class="st">    </span><span class="kw">mutate</span>(<span class="dt">mmlr =</span> <span class="kw">map_dbl</span>(symbol, my_stock_analysis_fun)) %&gt;%
<span class="st">    </span><span class="kw">arrange</span>(<span class="kw">desc</span>(mmlr))
stocks</code></pre></div>
<pre><code>## # A tibble: 10 × 3
##    symbol            company         mmlr
##     &lt;chr&gt;              &lt;chr&gt;        &lt;dbl&gt;
## 1    FLIR       FLIR SYSTEMS  0.009359061
## 2     CNP CENTERPOINT ENERGY  0.008680819
## 3     IVZ            INVESCO  0.007007588
## 4      SE     SPECTRA ENERGY  0.006579937
## 5    XRAY      DENTSPLY INTL  0.006211669
## 6     EMC                EMC  0.006210331
## 7    INTC              INTEL  0.005163667
## 8       L              LOEWS  0.003371969
## 9     MNK   MALLINCKRODT PLC  0.002366373
## 10    AIG      AMERICAN INTL -0.021078924</code></pre>
<p>And, we’re done! We now have the MMLR for 10-years of stock data for 10 stocks. And, we can easily extend this to larger lists or stock indexes. For example, the entire S&amp;P500 could be analyzed removing the <code>sample_n()</code> following the call to <code>tq_get(&quot;SP500&quot;, get = &quot;stock.index&quot;)</code>.</p>
</div>
<div id="function-tq_get-designed-to-handle-errors-gracefully" class="section level3">
<h3>Function <code>tq_get()</code> Designed to Handle Errors Gracefully</h3>
<p>Eventually you will run into a stock index, stock symbol, FRED data code, etc that cannot be retrieved. Possible reasons are:</p>
<ul>
<li>The website changes</li>
<li>An index becomes out of date</li>
<li>A company goes private</li>
<li>A stock ticker symbol changes</li>
<li>Yahoo / FRED just doesn’t like your stock symbol / FRED code</li>
</ul>
<p>This becomes painful when scaling if the functions return errors. So, the <code>tq_get()</code> function is designed to handle errors gracefully. What this means is a <code>NA</code> value is returned when an error is generated along with a gentle error warning. There are pros and cons to this approach that you may not agree with but I believe helps in the long run. Just be aware of what happens:</p>
<ul>
<li><p><strong>Pros</strong>: Long running scripts are not interrupted because of one error</p></li>
<li><p><strong>Cons</strong>: Errors flow downstream if not looking at warnings and not reviewing results</p></li>
</ul>
<p><strong>With <code>tq_get()</code>, Bad Apples Fail Gracefully</strong>:</p>
<p>Let’s see an example when mapping to <code>tq_get()</code> to a long list of stocks with one <code>BAD APPLE</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">stock_list_with_one_bad_apple &lt;-<span class="st"> </span><span class="kw">tibble</span>( 
    <span class="dt">symbol =</span> <span class="kw">c</span>(<span class="st">&quot;AAPL&quot;</span>, <span class="st">&quot;GOOG&quot;</span>, <span class="st">&quot;AMZN&quot;</span>, <span class="st">&quot;FB&quot;</span>, <span class="st">&quot;BAD APPLE&quot;</span>,
               <span class="st">&quot;AVGO&quot;</span>, <span class="st">&quot;SWKS&quot;</span>,<span class="st">&quot;NVDA&quot;</span>, <span class="st">&quot;V&quot;</span>, <span class="st">&quot;MA&quot;</span>)
)
stock_list_with_one_bad_apple &lt;-<span class="st"> </span>stock_list_with_one_bad_apple %&gt;%
<span class="st">    </span><span class="kw">mutate</span>(<span class="dt">stock.prices =</span> <span class="kw">map</span>(<span class="dt">.x =</span> symbol, ~<span class="st"> </span><span class="kw">tq_get</span>(.x, <span class="dt">get =</span> <span class="st">&quot;stock.prices&quot;</span>)))</code></pre></div>
<pre><code>## Warning in value[[3L]](cond): Error at stock symbol BAD APPLE during call
## to quantmod::getSymbols.</code></pre>
<p>We get warned that there was an issue in the operation. With that said, we still get the full list of stocks.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">stock_list_with_one_bad_apple</code></pre></div>
<pre><code>## # A tibble: 10 × 2
##       symbol         stock.prices
##        &lt;chr&gt;               &lt;list&gt;
## 1       AAPL &lt;tibble [2,769 × 7]&gt;
## 2       GOOG &lt;tibble [2,769 × 7]&gt;
## 3       AMZN &lt;tibble [2,769 × 7]&gt;
## 4         FB &lt;tibble [1,163 × 7]&gt;
## 5  BAD APPLE            &lt;lgl [1]&gt;
## 6       AVGO &lt;tibble [1,865 × 7]&gt;
## 7       SWKS &lt;tibble [2,769 × 7]&gt;
## 8       NVDA &lt;tibble [2,769 × 7]&gt;
## 9          V &lt;tibble [2,214 × 7]&gt;
## 10        MA &lt;tibble [2,670 × 7]&gt;</code></pre>
<p>Say hypothetically we didn’t recognize the error message. An error shows up during the next operation. As an example, we’ll attempt to get yearly period returns using <code>tq_transform</code>. The operation is wrapped in a <code>tryCatch()</code> statement to enable printing the error message.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tryCatch</span>({
    stock_list_with_one_bad_apple %&gt;%
<span class="st">    </span><span class="kw">mutate</span>(<span class="dt">annual.returns =</span> <span class="kw">map</span>(<span class="dt">.x =</span> stock.prices, 
                                ~<span class="st"> </span><span class="kw">tq_transform</span>(.x,
                                               <span class="dt">x_fun =</span> Ad, 
                                               <span class="dt">transform_fun =</span> periodReturn, 
                                               <span class="dt">period =</span> <span class="st">&quot;yearly&quot;</span>)
                                )
           )
}, <span class="dt">error =</span> function(e) {
    <span class="kw">print</span>(e)
})</code></pre></div>
<pre><code>## &lt;Rcpp::eval_error in eval(substitute(expr), envir, enclos): `data` must be a tibble or data.frame.&gt;</code></pre>
<p>The operation grinds to a hault because the <code>BAD APPLE</code> tried to send its value for stock.prices of <code>NA</code> to the <code>tq_transform()</code> function. The error message tells us that <code>data</code> is not a <code>tibble</code> or <code>data.frame</code>.</p>
<p>The rationale behind the error handling approach is that long-running scripts should not fail during minor issues. For example, if you have a list of 3000 stocks and the 3000th is bad, the program could take 20+ minutes to fail. This is disheartening. We allow <code>tq_get()</code> to continue to fetch data even if an error is encountered. Failure occurs during <code>tq_transform()</code> and <code>tq_mutate()</code> to prevent the error from getting too far downstream.</p>
<p>Recognizing how <code>tq_get()</code> works (and gracefully fails), we can adjust our workflow. It’s a good idea to collect stock information in one independent step, review any warnings / errors, and remove “bad apples” if present before moving on to any transformations or mutations.</p>
<p>Here’s an example of a good workflow:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">stock_list_with_one_bad_apple &lt;-<span class="st"> </span><span class="kw">tibble</span>( 
    <span class="dt">symbol =</span> <span class="kw">c</span>(<span class="st">&quot;AAPL&quot;</span>, <span class="st">&quot;GOOG&quot;</span>, <span class="st">&quot;AMZN&quot;</span>, <span class="st">&quot;FB&quot;</span>, <span class="st">&quot;BAD APPLE&quot;</span>,
               <span class="st">&quot;AVGO&quot;</span>, <span class="st">&quot;SWKS&quot;</span>,<span class="st">&quot;NVDA&quot;</span>, <span class="st">&quot;V&quot;</span>, <span class="st">&quot;MA&quot;</span>)
    ) %&gt;%
<span class="st">    </span><span class="co"># Step 1: Get stock prices</span>
<span class="st">    </span><span class="kw">mutate</span>(<span class="dt">stock.prices =</span> <span class="kw">map</span>(<span class="dt">.x =</span> symbol, ~<span class="st"> </span><span class="kw">tq_get</span>(.x, <span class="dt">get =</span> <span class="st">&quot;stock.prices&quot;</span>)),
           <span class="dt">class =</span> <span class="kw">map_chr</span>(stock.prices, ~<span class="st"> </span><span class="kw">class</span>(.x)[[<span class="dv">1</span>]])) %&gt;%
<span class="st">    </span><span class="co"># Step 2: Filter out errors; errors have a class of &quot;logical&quot;</span>
<span class="st">    </span><span class="kw">filter</span>(class !=<span class="st"> &quot;logical&quot;</span>) %&gt;%
<span class="st">    </span><span class="kw">select</span>(-class) %&gt;%
<span class="st">    </span><span class="co"># Step 3: Perform period returns</span>
<span class="st">    </span><span class="kw">mutate</span>(<span class="dt">annual.returns =</span> <span class="kw">map</span>(<span class="dt">.x =</span> stock.prices, 
                                ~<span class="st"> </span><span class="kw">tq_transform</span>(.x,
                                               <span class="dt">x_fun =</span> Ad, 
                                               <span class="dt">transform_fun =</span> periodReturn, 
                                               <span class="dt">period =</span> <span class="st">&quot;yearly&quot;</span>)
                                )
           )
stock_list_with_one_bad_apple</code></pre></div>
<pre><code>## # A tibble: 9 × 3
##   symbol         stock.prices    annual.returns
##    &lt;chr&gt;               &lt;list&gt;            &lt;list&gt;
## 1   AAPL &lt;tibble [2,769 × 7]&gt; &lt;tibble [11 × 2]&gt;
## 2   GOOG &lt;tibble [2,769 × 7]&gt; &lt;tibble [11 × 2]&gt;
## 3   AMZN &lt;tibble [2,769 × 7]&gt; &lt;tibble [11 × 2]&gt;
## 4     FB &lt;tibble [1,163 × 7]&gt;  &lt;tibble [5 × 2]&gt;
## 5   AVGO &lt;tibble [1,865 × 7]&gt;  &lt;tibble [8 × 2]&gt;
## 6   SWKS &lt;tibble [2,769 × 7]&gt; &lt;tibble [11 × 2]&gt;
## 7   NVDA &lt;tibble [2,769 × 7]&gt; &lt;tibble [11 × 2]&gt;
## 8      V &lt;tibble [2,214 × 7]&gt;  &lt;tibble [9 × 2]&gt;
## 9     MA &lt;tibble [2,670 × 7]&gt; &lt;tibble [11 × 2]&gt;</code></pre>
<p><strong>Fall Back for Stock Indexes</strong>:</p>
<p>There’s a fallback for the stock indexes too. Since the source, www.marketvolume.com, could change over time, an option is provided to pull stored data within the <code>tidyquant</code> package. The downside is that the data is only as accurate as the last update to <code>tidyquant</code>. Here’s how to get the stock indexes locally if for some reason the website is down or has changed.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tq_get</span>(<span class="st">&quot;SP500&quot;</span>, <span class="dt">get =</span> <span class="st">&quot;stock.index&quot;</span>, <span class="dt">use_fallback =</span> <span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## Using fallback dataset last downloaded 2016-12-23.</code></pre>
<pre><code>## # A tibble: 501 × 2
##    symbol                   company
##     &lt;chr&gt;                     &lt;chr&gt;
## 1     MMM                        3M
## 2     ABT       ABBOTT LABORATORIES
## 3    ABBV                ABBVIE INC
## 4     ACN                 ACCENTURE
## 5    ATVI       ACTIVISION BLIZZARD
## 6     AYI             ACUITY BRANDS
## 7    ADBE             ADOBE SYSTEMS
## 8     AAP        ADVANCE AUTO PARTS
## 9     AET                     AETNA
## 10    AMG AFFILIATED MANAGERS GROUP
## # ... with 491 more rows</code></pre>
</div>
</div>
</div>
<div id="recap" class="section level1">
<h1>Recap</h1>
<p>Hopefully now you see how <code>tidyquant</code> helps to integrate the best quantitative financial analysis packages with the <code>tidyverse</code>. The benefits are:</p>
<ul>
<li>A few core functions with a lot of power, that</li>
<li>leverage the quantitative analysis power of <code>xts</code>, <code>quantmod</code> and <code>TTR</code>, and are</li>
<li>designed to be scaled with the <code>tidyverse</code> workflow.</li>
</ul>
<p>With a few, easy-to-use core functions, you can efficiently leverage the quantitative power of <code>xts</code>, <code>quantmod</code> and <code>TTR</code> with the data management infrastructure and scale-ability of the <code>tidyverse</code>.</p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
